# Solution

So I tried a few things here and did my best to keep my solution clean and simple, easy to read and understand, I did some testing with external libraries and just simple JS. Here you can find 3 solutions for the sync method, result of my experimentation. `sync-sorted-merge` is similar to the `sync-sorted-mege-simple` one with the added condition that checks if the next element on the current logSource is before the next logSource log, this reduces the operations in the set array making it a bit faster.

Later added a heap lib and saw similar results for small sets, one of the issues with the simple solution is that the bigger the set, the longer it takes to position the element in the set array, so a Binary Tree or a similar data structure improves on this and this is why the heap is the one I left as default on the index file since it performs a lot better for bigger sets.

For the async, used a heap solution with node workers, basically the worker holds the set with the logs in order and the main thread handles the promises in parallel. In order for the code to work a 2ms delay is added to the worker so logs have time to finish fetching and are added to the set. I think this can be further improved by removing the worker that is adding extra loads with the JSON parsing back and forth but I found this to be an insteresting approach so went for it as my final solution.

On average, my mac was able to log 15 to 18K per second logs for the sync, for the Sync I got up to 500 logs per second, I think this can get up to the thousands if the worker is removed and a single thread with parallel promises is used.






















































































































































































































































































































































